-- Generated by Oracle SQL Developer Data Modeler 4.0.2.840
--   at:        2014-11-13 20:15:22 MST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g




CREATE TABLE Accounts
  (
    --  Although Username must be unique, it can be changed. This ID doesn't
    --  change. Having this unchangeable ID allows the username to be changed with
    --  fewer other changes having to be propagated through the database as a
    --  result of that one change.
    ID          NUMBER (10) NOT NULL ,
    Username    VARCHAR2 (16) NOT NULL ,
    PWord       VARCHAR2 (16) NOT NULL ,
    WhenCreated TIMESTAMP DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  Most recent date that the account was unlocked. For new accounts, it should
    --  be set to the same date as WhenCreated.
    --  This is to deal with scenarios when an administrator has unlocked an
    --  account upon the user's request, in the same calendar day that the user
    --  locked themselves out (with too many failed login attempts). In such an
    --  event, the user would again lock themselves out if they have a failed login
    --  attempt even once in that same day!
    --  With this column, the 3 failed login attempts must all occur after the
    --  UnlockDate (in addition to being on the same calendar day) in order to
    --  cause a lockout.
    UnlockDate TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  If NULL, the account is unlocked. Otherwise, the value is the timestamp
    --  when it was locked.
    LockDate TIMESTAMP (4) DEFAULT NULL
  )
  LOGGING ;
ALTER TABLE Accounts ADD CONSTRAINT USERNAME_PWORD_NOT_SAME CHECK (TRIM(Username)         != TRIM(PWord)) ;
ALTER TABLE Accounts ADD CONSTRAINT PWORD_START_UPPERCASE CHECK (SUBSTR(PWord, 1, 1)       = UPPER(SUBSTR(PWord, 1, 1))) ;
ALTER TABLE Accounts ADD CONSTRAINT USERNAME_START_UPPERCASE CHECK (SUBSTR(Username, 1, 1) = UPPER(SUBSTR(Username, 1, 1))) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_PK PRIMARY KEY ( ID ) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_Username_UN UNIQUE ( Username ) ;

CREATE TABLE LoginAttempts
  (
    Accounts_ID   NUMBER (10) NOT NULL ,
    WhenAttempted TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  'Y' or 'N'
    WasSuccessful CHAR (1) DEFAULT 'N' NOT NULL
  )
  LOGGING ;
ALTER TABLE LoginAttempts ADD CHECK ( WasSuccessful IN ('N', 'Y')) ;
ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_PK PRIMARY KEY ( WhenAttempted, Accounts_ID ) ;

CREATE OR REPLACE VIEW V_LoginAttempts ( Accounts_ID
   , WhenAttempted
   , WasSuccessful )
 AS SELECT
    Accounts_ID
   , WhenAttempted
   , WasSuccessful
 FROM 
    LoginAttempts ;






--  If the entered username doesn't match any account, no login attempt is
--  recorded. If it does, then a login attempt (successful or unsuccesful) is
--  recorded. A wrong password will cause an unsuccessful login attempt to be
--  recorded, as will any attempt while the account is locked.
create or replace PROCEDURE Login_SP(UNameEntry IN Accounts.Username%TYPE,
                                  PWordEntry IN Accounts.PWord%TYPE)

IS
  IDVar               Accounts.ID%TYPE;
  UNameVar            Accounts.Username%TYPE;
  PWordVar            Accounts.PWord%TYPE;
  LockDateVar         Accounts.LockDate%TYPE;
  UserCountVar        NUMERIC(2) NOT NULL := 0;
  CurrTimestampVar    TIMESTAMP;

BEGIN
  SELECT LOCALTIMESTAMP INTO CurrTimestampVar FROM DUAL;

  SELECT COUNT(Accounts.ID) INTO UserCountVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  
  IF UserCountVar != 1 THEN
    DBMS_OUTPUT.PUT_LINE('Invalid username.');
    
  ELSE  
    SELECT Accounts.Username INTO UNameVar FROM Accounts
    WHERE Accounts.Username = UNameEntry;
    SELECT Accounts.ID INTO IDVar FROM Accounts
    WHERE Accounts.Username = UNameEntry;
    SELECT Accounts.LockDate INTO LockDateVar FROM Accounts
    WHERE Accounts.Username = UNameEntry;
  
    IF LockDateVar IS NOT NULL THEN
      INSERT INTO V_LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
    ELSE  
      SELECT Accounts.PWord INTO PWordVar FROM Accounts
      WHERE Accounts.Username = UNameEntry;
    
      IF PWordEntry != PWordVar THEN
        INSERT INTO V_LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
      ELSE
        INSERT INTO V_LoginAttempts VALUES (IDVar, CurrTimestampVar, 'Y');
      END IF;
    END IF;
  END IF;

END Login_SP;
/

CREATE TABLE Sessions
  (
    Accounts_ID   NUMBER (10) NOT NULL ,
    WhenInitiated TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  If NULL, the session is still active. Otherwise, the value is the timestamp
    --  when the session was terminated.
    --  When a new session for a given account is initiated, all other open
    --  sessions for that account are terminated.
    WhenTerminated TIMESTAMP (4) DEFAULT NULL
  )
  LOGGING ;
ALTER TABLE Sessions ADD CONSTRAINT Sessions_PK PRIMARY KEY ( Accounts_ID, WhenInitiated ) ;

ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_Accounts_FK FOREIGN KEY ( Accounts_ID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

ALTER TABLE Sessions ADD CONSTRAINT Sessions_Accounts_FK FOREIGN KEY ( Accounts_ID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

CREATE OR REPLACE VIEW V_Sessions ( Accounts_ID
   , WhenInitiated
   , WhenTerminated )
 AS SELECT
    Accounts_ID
   , WhenInitiated
   , WhenTerminated
 FROM 
    Sessions ;






--  Failed login attempts are recorded, and a warning is displayed about the
--  number of attempts left. On the 3rd failed login attempt since the last
--  unlock date, if all 3 are on the same day, the account is locked and a
--  corresponding message displayed.
--  Here "same day" means the same calendar day, not the same 24-hour-period).
CREATE OR REPLACE TRIGGER V_LoginAttempts_Insert_TRG 
    INSTEAD OF INSERT ON V_LoginAttempts REFERENCING 
    NEW AS NewRow 
    FOR EACH ROW 
    ENABLE 
DECLARE

FailedCountVar		NUMERIC(2) NOT NULL := 0;
LockDateVar		Accounts.LockDate%TYPE;

BEGIN

IF :NewRow.WasSuccessful = 'N' THEN
  SELECT Accounts.LockDate INTO LockDateVar FROM Accounts
  WHERE Accounts.ID = :NewRow.Accounts_ID;
  
	IF LockDateVar IS NOT NULL THEN
		DBMS_OUTPUT.PUT_LINE('The account is locked.' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
	ELSE
		SELECT COUNT(LoginAttempts.Accounts_ID) INTO FailedCountVar FROM LoginAttempts
		WHERE LoginAttempts.Accounts_ID = :NewRow.Accounts_ID
		AND LoginAttempts.WasSuccessful = 'N'
		AND TRUNC(LoginAttempts.WhenAttempted) = TRUNC(:NewRow.WhenAttempted)
		AND LoginAttempts.WhenAttempted > (SELECT Accounts.UnlockDate FROM Accounts WHERE Accounts.ID = :NewRow.Accounts_ID);
	
		FailedCountVar := FailedCountVar + 1;
	
		IF FailedCountVar < 3 THEN
			DBMS_OUTPUT.PUT_LINE('Invalid password.' || CHR(13) || CHR(10) || (3 - FailedCountVar) || ' attempt(s) left before the account will be locked!');
		ELSE
			UPDATE Accounts
				SET Accounts.LockDate = :NewRow.WhenAttempted
				WHERE Accounts.ID = :NewRow.Accounts_ID;
			DBMS_OUTPUT.PUT_LINE('Invalid password. The account is now locked!' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
		END IF;
	END IF;
ELSE
    DBMS_OUTPUT.PUT_LINE('Login successful.');
    INSERT INTO V_Sessions VALUES (:NewRow.Accounts_ID, :NewRow.WhenAttempted, NULL);
END IF;

INSERT INTO LoginAttempts VALUES (:NewRow.Accounts_ID, :NewRow.WhenAttempted, :NewRow.WasSuccessful);

END V_LoginAttempts_Insert_TRG; 
/




--  If the user has any previous sessions that were not terminated, they are
--  updated to have a termination timestamp which is the same as the timestamp
--  that is used to initiate the new session. The new session has its
--  termination date left null.
CREATE OR REPLACE TRIGGER V_Sessions_Insert_TRG 
    INSTEAD OF INSERT ON V_Sessions REFERENCING 
    NEW AS NewRow 
    FOR EACH ROW 
    ENABLE 
BEGIN
	UPDATE Sessions
		SET Sessions.WhenTerminated = :NewRow.WhenInitiated
		WHERE Sessions.Accounts_ID = :NewRow.Accounts_ID
		AND Sessions.WhenTerminated IS NULL;

	INSERT INTO Sessions VALUES (:NewRow.Accounts_ID, :NewRow.WhenInitiated, NULL);
  DBMS_OUTPUT.PUT_LINE('Cleaned up any previous sessions for this user and opened a new session.');
END V_Sessions_Insert_TRG; 
/



CREATE SEQUENCE Accounts_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER Accounts_ID_TRG BEFORE
  INSERT ON Accounts FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := Accounts_ID_SEQ.NEXTVAL;
END;
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             3
-- CREATE INDEX                             0
-- ALTER TABLE                             10
-- CREATE VIEW                              2
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         1
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                           3
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          1
-- CREATE MATERIALIZED VIEW                 0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
