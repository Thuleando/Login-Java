-- Generated by Oracle SQL Developer Data Modeler 4.0.2.840
--   at:        2014-11-19 21:23:45 MST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g




CREATE TABLE Accounts
  (
    --  Although Username must be unique, it can be changed. This ID doesn't
    --  change. Having this unchangeable ID allows the username to be changed with
    --  fewer other changes having to be propagated through the database as a
    --  result of that one change.
    ID       NUMBER (10) NOT NULL ,
    Username VARCHAR2 (16) NOT NULL ,
    PWord    VARCHAR2 (50) NOT NULL ,
    --  Defaults to type 2 (should be User).
    AccountTypes_ID NUMBER (10) DEFAULT 2 NOT NULL ,
    WhenCreated     TIMESTAMP DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  If 'Y' the account is locked, if 'N' the account is unlocked.
    LockStatus CHAR (1) DEFAULT 'N' NOT NULL
  )
  LOGGING ;
ALTER TABLE Accounts ADD CHECK ( LockStatus IN ('N', 'Y')) ;
ALTER TABLE Accounts ADD CONSTRAINT USERNAME_START_UPPERCASE CHECK (SUBSTR(Username, 1, 1) = UPPER(SUBSTR(Username, 1, 1))) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_PK PRIMARY KEY ( ID ) ;
ALTER TABLE Accounts ADD CONSTRAINT Accounts_Username_UN UNIQUE ( Username ) ;

CREATE TABLE LockEvents
  (
    ID          NUMBER (10) NOT NULL ,
    Accounts_ID NUMBER (10) NOT NULL ,
    --  Only 2 valid values:
    --  'L' = Locked
    --  'U' = Unlocked
    EventType       CHAR (1) DEFAULT 'U' NOT NULL ,
    EventDate       TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    EventReasons_ID NUMBER (10) DEFAULT 1 NOT NULL
  )
  LOGGING ;
ALTER TABLE LockEvents ADD CHECK ( EventType IN ('L', 'U')) ;
ALTER TABLE LockEvents ADD CONSTRAINT LockEvents_PK PRIMARY KEY ( ID ) ;


create or replace PROCEDURE CreateAccount_SP 
(
  USERNAME_IN IN VARCHAR2, 
  PASSWORD_IN IN VARCHAR2,
  RESULT      OUT NUMBER 
) 
AS 
ValidUN         Accounts.USERNAME%TYPE;
AccID           Accounts.ID%TYPE;
ACCOUNT_EXISTS  Exception;

BEGIN
  <<Check_Account_Exists>>
  BEGIN
    SELECT Accounts.UserName INTO ValidUN FROM Accounts 
                WHERE UserName = USERNAME_IN;
    Exception
      WHEN NO_DATA_FOUND THEN
        -- DBMS_OUTPUT.PUT_LINE('No Account found');
        ValidUN := null;
  END Check_Account_Exists;
  
  IF ValidUN is not null THEN
       --DBMS_OUTPUT.PUT_LINE('If is true');
    RAISE ACCOUNT_EXISTS;
  END IF;

  --DBMS_OUTPUT.PUT_LINE(validUN);
  INSERT INTO Accounts (Username, PWord) VALUES(USERNAME_IN, PASSWORD_IN);
  COMMIT;
  SELECT Accounts.ID INTO AccID FROM Accounts 
                WHERE UserName = USERNAME_IN;
  INSERT INTO LockEvents (Accounts_ID) VALUES(AccID);
  RESULT := 1;

  Exception
  WHEN ACCOUNT_EXISTS THEN
    RESULT := 2;
  WHEN OTHERS THEN
    RESULT := 3;
  NULL;
END CREATEACCOUNT_SP;
/

CREATE TABLE LoginAttempts
  (
    Accounts_ID   NUMBER (10) NOT NULL ,
    WhenAttempted TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  'Y' or 'N'
    WasSuccessful CHAR (1) DEFAULT 'N' NOT NULL
  )
  LOGGING ;
ALTER TABLE LoginAttempts ADD CHECK ( WasSuccessful IN ('N', 'Y')) ;
ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_PK PRIMARY KEY ( WhenAttempted, Accounts_ID ) ;

CREATE TABLE Sessions
  (
    Accounts_ID   NUMBER (10) NOT NULL ,
    WhenInitiated TIMESTAMP (4) DEFAULT LOCALTIMESTAMP NOT NULL ,
    --  If NULL, the session is still active. Otherwise, the value is the timestamp
    --  when the session was terminated.
    --  When a new session for a given account is initiated, all other open
    --  sessions for that account are terminated.
    WhenTerminated TIMESTAMP (4) DEFAULT NULL
  )
  LOGGING ;
ALTER TABLE Sessions ADD CONSTRAINT Sessions_PK PRIMARY KEY ( Accounts_ID, WhenInitiated ) ;


--  If the entered username doesn't match any account, no login attempt is
--  recorded. If it does, then a login attempt (successful or unsuccesful) is
--  recorded. A wrong password will cause an unsuccessful login attempt to be
--  recorded, as will any attempt while the account is locked.
create or replace PROCEDURE Login_SP( UNameEntry    IN Accounts.Username%TYPE,
                                      PWordEntry    IN Accounts.PWord%TYPE,
                                      Results       OUT INTEGER,
                                      ResultDescrip OUT Varchar2)

IS

  Invalid_User        EXCEPTION;
  Invalid_PWord       EXCEPTION;
  Locked_Out          EXCEPTION;
  Locking_Out         EXCEPTION;

  IDVar               Accounts.ID%TYPE;
  UNameVar            Accounts.Username%TYPE;
  PWordVar            Accounts.PWord%TYPE;
  LockStatusVar       Accounts.LockStatus%TYPE;
  FailedCountVar      NUMERIC(2) NOT NULL := 0;
  UserCountVar        NUMERIC(2) NOT NULL := 0;
  CurrTimestampVar    TIMESTAMP(4);
  LastUnlock          TIMESTAMP(4);

BEGIN
  SELECT LOCALTIMESTAMP INTO CurrTimestampVar FROM DUAL;

  SELECT COUNT(Accounts.ID) INTO UserCountVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  
  IF UserCountVar != 1 THEN
    RAISE Invalid_User;
  END IF;
  
  SELECT Accounts.Username INTO UNameVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  SELECT Accounts.ID INTO IDVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;
  SELECT Accounts.LockStatus INTO LockStatusVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;

  IF LockStatusVar = 'Y' THEN
    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
    RAISE Locked_Out;
  END IF;

  SELECT Accounts.PWord INTO PWordVar FROM Accounts
  WHERE Accounts.Username = UNameEntry;

  IF PWordEntry != PWordVar OR PWordEntry IS NULL THEN
  
    SELECT MAX(LockEvents.EventDate) INTO LastUnlock FROM LockEvents
    WHERE LockEvents.Accounts_ID = IDVar
    AND LockEvents.EventType = 'U';

    SELECT COUNT(LoginAttempts.Accounts_ID) INTO FailedCountVar FROM LoginAttempts
    WHERE LoginAttempts.Accounts_ID = IDVar
    AND LoginAttempts.WasSuccessful = 'N'
    AND TRUNC(LoginAttempts.WhenAttempted) = TRUNC(CurrTimestampVar)
    AND LoginAttempts.WhenAttempted > LastUnlock;

    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'N');
    FailedCountVar := FailedCountVar + 1;

    IF FailedCountVar < 3 THEN
      RAISE Invalid_PWord;
    ELSE
      UPDATE Accounts
        SET LockStatus = 'Y'
        WHERE Accounts.ID = IDVar;
      INSERT INTO LockEvents (Accounts_ID, EventType, EventDate, EventReasons_ID) VALUES (IDVar, 'L', CurrTimestampVar, 2);
      RAISE Locking_Out;
    END IF;
  ELSE
    INSERT INTO LoginAttempts VALUES (IDVar, CurrTimestampVar, 'Y');
    ResultDescrip := 'Login Success:'|| CHR(13) || CHR(10) || UNameEntry || ' is now logged in.';
    Results := 1;
  
    UPDATE Sessions
      SET WhenTerminated = CurrTimestampVar
      WHERE Sessions.Accounts_ID = IDVar
      AND Sessions.WhenTerminated IS NULL;
  
    INSERT INTO Sessions VALUES (IDVar, CurrTimestampVar, NULL);
  END IF;

EXCEPTION
  WHEN Invalid_User THEN
    Results := 2;
    ResultDescrip := 'Login Failed: Account does not exist.';
    --RAISE_APPLICATION_ERROR(-20001, 'Invalid username.');
  WHEN Locked_Out THEN
     Results := 5;
    ResultDescrip := 'The account is locked.' || CHR(13) || CHR(10) || 'Please contact administrator for more information.';
    COMMIT;
    --RAISE_APPLICATION_ERROR(-20002, 'The account is locked.' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
  WHEN Invalid_PWord THEN
     Results := 3;
    ResultDescrip := 'Invalid password.' || CHR(13) || CHR(10) || (3 - FailedCountVar) || ' attempts left before the account will be locked!';
    COMMIT;
    --RAISE_APPLICATION_ERROR (-20003, 'Invalid password.' || CHR(13) || CHR(10) || (3 - FailedCountVar) || ' attempts left before the account will be locked!');
  WHEN Locking_Out THEN
       Results := 5;
    ResultDescrip := 'Invalid password. The account is now locked!' || CHR(13) || CHR(10) || 'Please contact administrator for more information.';
    COMMIT;
    --RAISE_APPLICATION_ERROR (-20004, 'Invalid password. The account is now locked!' || CHR(13) || CHR(10) || 'Please contact administrator for more information.');
  WHEN OTHERS THEN
       Results := 4;
    ResultDescrip := 'Unknown Error.';
    --RAISE_APPLICATION_ERROR (-20000, 'Unknown Error.');

END Login_SP;
/


create or replace PROCEDURE Unlock_SP 
                          (
                            ACCOUNTID_IN  IN NUMBER,
                            REASONID_IN   IN NUMBER,
                            RESULTS       OUT NUMBER 
                          )
AS

BEGIN
  UPDATE Accounts
    SET LockStatus = 'N'
    WHERE Accounts.ID = ACCOUNTID_IN;
  INSERT INTO LockEvents (Accounts_ID, EventType, EventReasons_ID) VALUES (ACCOUNTID_IN, 'U', REASONID_IN);
  RESULTS := 1;

EXCEPTION
  WHEN OTHERS THEN
    RESULTS := 2;

END Unlock_SP;
/

CREATE TABLE AccountTypes
  (
    --  When we populate it, let's put Admin as type 1, and User as type 2.
    ID NUMBER (10) NOT NULL ,
    --  When we populate it, let's put Admin as type 1, and User as type 2.
    TypeName VARCHAR2 (20) NOT NULL
  )
  LOGGING ;
ALTER TABLE AccountTypes ADD CONSTRAINT AccountTypes_PK PRIMARY KEY ( ID ) ;
ALTER TABLE AccountTypes ADD CONSTRAINT AccountTypes_TName_UN UNIQUE ( TypeName ) ;

CREATE TABLE EventReasons
  (
    --  When we populate it, let's put Creation as reason 1 (with ReasonType 'U'),
    --  and AutoLock (with ReasonType 'L') as type 2.
    --  ... or whatever a better name for "Autolock" might be.
    ID         NUMBER (10) NOT NULL ,
    ReasonName VARCHAR2 (16) NOT NULL ,
    --  'L' = Reason for locking
    --  'U' = Reason for unlocking
    ReasonType  CHAR (1) DEFAULT 'L' NOT NULL ,
    Description VARCHAR2 (120)
  )
  LOGGING ;
ALTER TABLE EventReasons ADD CHECK ( ReasonType IN ('L', 'U')) ;
ALTER TABLE EventReasons ADD CONSTRAINT EventReasons_PK PRIMARY KEY ( ID ) ;
ALTER TABLE EventReasons ADD CONSTRAINT EventReasons_RName_UN UNIQUE ( ReasonName ) ;

ALTER TABLE Accounts ADD CONSTRAINT Accounts_AccountTypes_FK FOREIGN KEY ( AccountTypes_ID ) REFERENCES AccountTypes ( ID ) NOT DEFERRABLE ;

ALTER TABLE LockEvents ADD CONSTRAINT LockEvents_Accounts_FK FOREIGN KEY ( Accounts_ID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

ALTER TABLE LockEvents ADD CONSTRAINT LockEvents_EReasons_FK FOREIGN KEY ( EventReasons_ID ) REFERENCES EventReasons ( ID ) NOT DEFERRABLE ;

ALTER TABLE LoginAttempts ADD CONSTRAINT LoginAttempts_Accounts_FK FOREIGN KEY ( Accounts_ID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

ALTER TABLE Sessions ADD CONSTRAINT Sessions_Accounts_FK FOREIGN KEY ( Accounts_ID ) REFERENCES Accounts ( ID ) NOT DEFERRABLE ;

CREATE SEQUENCE AccountTypes_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER AccountTypes_ID_TRG BEFORE
  INSERT ON AccountTypes FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := AccountTypes_ID_SEQ.NEXTVAL;
END;
/

CREATE SEQUENCE Accounts_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER Accounts_ID_TRG BEFORE
  INSERT ON Accounts FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := Accounts_ID_SEQ.NEXTVAL;
END;
/

CREATE SEQUENCE EventReasons_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER EventReasons_ID_TRG BEFORE
  INSERT ON EventReasons FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := EventReasons_ID_SEQ.NEXTVAL;
END;
/

CREATE SEQUENCE LockEvents_ID_SEQ START WITH 1 NOCACHE ORDER ;
CREATE OR REPLACE TRIGGER LockEvents_ID_TRG BEFORE
  INSERT ON LockEvents FOR EACH ROW WHEN (NEW.ID IS NULL) BEGIN :NEW.ID := LockEvents_ID_SEQ.NEXTVAL;
END;
/


-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             6
-- CREATE INDEX                             0
-- ALTER TABLE                             19
-- CREATE VIEW                              0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         3
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                           4
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          4
-- CREATE MATERIALIZED VIEW                 0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
